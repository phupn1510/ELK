input {
    beats {
        port => 5044    
        # ssl => true
        # ssl_certificate => "/etc/pki/tls/certs/logstash-forwarder.crt"
        # ssl_key => "/etc/pki/tls/private/logstash-forwarder.key"
   }

}

filter {
if [type] == "syslog" {

grok {
      match => { "message" => "%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:syslog_hostname} %{DATA:syslog_program}(?:\[%{POSINT:syslog_pid}\])?: %{GREEDYDATA:syslog_message}" }
      add_field => [ "received_at", "%{@timestamp}" ]
      add_field => [ "received_from", "%{host}" ]
    }
    syslog_pri { }
    date {
      match => [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
    }
}
  
if [type] == "auth-log" {
 grok {
    add_tag => [ "valid" ]

    # Example log entries for both failed and successful logins:
    #
    # Aug  9 09:13:25 vmubu01 sshd[5761]: Failed password for root from 218.87.111.109 port 45712 ssh2
    # Aug  9 09:13:31 vmubu01 sshd[5761]: message repeated 2 times: [ Failed password for root from 218.87.111.109 port 45712 ssh2]
    # Aug 14 17:25:47 vmubu01 sshd[22101]: Failed password for invalid user test from 115.68.23.130 port 43092 ssh2
    # Aug 16 13:47:44 vmubu01 sshd[730]: Accepted publickey for username from 192.168.1.225 port 38783 ssh2: RSA 01:02:03:04:05:06:07:08:09:0a:0b:0c:0d:0e:0f:10
    # Aug 16 13:47:57 vmubu01 sshd[816]: Accepted password for username from 192.168.1.225 port 38786 ssh2
    match => [
      "message", "%{SYSLOGTIMESTAMP:syslog_date} %{SYSLOGHOST:syslog_host} %{DATA:syslog_program}(?:\[%{POSINT}\])?: %{WORD:login} password for %{USERNAME:username} from %{IP:clientip} %{GREEDYDATA}",
      "message", "%{SYSLOGTIMESTAMP:syslog_date} %{SYSLOGHOST:syslog_host} %{DATA:syslog_program}(?:\[%{POSINT}\])?: message repeated 2 times: \[ %{WORD:login} password for %{USERNAME:username} from %{IP:clientip} %{GREEDYDATA}",
      "message", "%{SYSLOGTIMESTAMP:syslog_date} %{SYSLOGHOST:syslog_host} %{DATA:syslog_program}(?:\[%{POSINT}\])?: %{WORD:login} password for invalid user %{USERNAME:username} from %{IP:clientip} %{GREEDYDATA}",
      "message", "%{SYSLOGTIMESTAMP:syslog_date} %{SYSLOGHOST:syslog_host} %{DATA:syslog_program}(?:\[%{POSINT}\])?: %{WORD:login} %{WORD:auth_method} for %{USERNAME:username} from %{IP:clientip} %{GREEDYDATA}"
    ]
  }


}
grok {
match => [ "message" , "%{COMBINEDAPACHELOG}+%{GREEDYDATA:extra_fields}"]
overwrite => [ "message" ]
add_field => { "nginxlog" => "nginx-access" }
}


 
grok {
match => [ "message" , "(?<timestamp>%{YEAR}[./-]%{MONTHNUM}[./-]%{MONTHDAY}[- ]%{TIME}) \[%{LOGLEVEL:severity}\] %{POSINT:pid}#%{NUMBER}: %{GREEDYDATA:errormessage}(?:, clientip: (?<client>%{IP}|%{HOSTNAME}))(?:, server: %{IPORHOST:server})(?:, request: %{QS:request})?(?:, upstream: \"%{URI:upstream}\")?(?:, host: %{QS:host})?(?:, referrer: \"%{URI:referrer}\")"]
overwrite => [ "message" ]
add_field => { "nginxlog" => "nginx-error" }
}
  
mutate {
convert => ["response", "integer"]
convert => ["bytes", "integer"]
convert => ["responsetime", "float"]
convert => [ "[geoip][coordinates]", "float"]

}
 
geoip {
source => "clientip"
target => "geoip"
add_tag => [ "nginx-geoip" ]
add_field => [ "[geoip][coordinates]", "%{[geoip][longitude]}" ]
add_field => [ "[geoip][coordinates]", "%{[geoip][latitude]}"  ]
}
 
date {
match => [ "timestamp" , "dd/MMM/YYYY:HH:mm:ss Z" ]
remove_field => [ "timestamp" ]
} 
useragent {
source => "agent"
} 

if [agent] =~ /\"Go-http-client\/1.1"/
  {
    drop {}
  }
  #}
  
#if [type] == "nginx-error" {

 
#geoip {
#source => "client"
#target => "geoip"
#add_tag => [ "nginx-geoip" ]
#}
 
#date {
#match => [ "timestamp" , "YYYY/MM/dd HH:mm:ss" ]
#add_field => { "received_at" => "%{YYYY/MM/dd}"}
#remove_field => [ "timestamp" ]
#match => [ "timestamp" , "${TIMESTAMP_ISO8601}" ]
#add_field => { "received_at" => "%{YYYY/MM/dd}"}
#remove_field => [ "timestamp" ]
#}
#}
#   if [response] == "404" { 
#      metrics {
#      meter => [ "count404" ]
#      flush_interval => 30
#      clear_interval => 30
#      add_tag => "metric"
#    }

}



output {
 

  if [type] != "collectd" { 
   elasticsearch {
    hosts => "elasticsearch:9200"
    manage_template => false
    index => "%{[@metadata][beat]}-%{+YYYY.MM.dd}"
    document_type => "%{[@metadata][type]}"
 }
}

#if [system][filesystem][device_name] == "/dev/xvda1" {
#stdout {
# codec => rubydebug { metadata => true }
 
 #}
#}

}